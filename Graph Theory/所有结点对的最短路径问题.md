# 所有结点对的最短路径问题

所谓全局最短路径，就是求出所有点之间的最短路径。最直观的做法就是跑|V|次单源最短路，俗称Johnson算法，但是更为行之有效的方法则是Floyd算法。Floyd算法 又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法。

## Johnson算法



## Floyd算法(Floyd–Warshall algorithm)

### 算法思想

递推产生一个$n$阶方阵序列$A^{(-1)},A^{(0)},...,A^{(k)},...,A^{(n-1)}$，其中$A^{(k)}[i][j]$表示从顶点$v_i$到顶点$v_j$的路径长度，$k$表示绕行第$k$个顶点的运算步骤。

初始时，对于任意两个顶点$v_i$和$v_j$，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以$\infty$作为它们之间的最短路径长度。

以后逐步尝试在原路径中加入顶点$k(k=0,1,...,n-1)$作为中间点。若增加中间点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。

### 算法步骤

定义一个$n$阶方阵序列$A^{(-1)},A^{(0)},...,A^{(k)},...,A^{(n-1)}$，其中
$$
A^{(-1)}[i][j]=arcs[i][j]
$$

$$
A^{(k)}[i][j]=Min\{A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j],k=0,1,...,n-1   \}
$$

式中，$A^{(0)[i][j]}$是从顶点$v_i$到$v_j$、中间顶点是$v_0$的最短路径的长度，$A^{(k)}[i][j]$是从顶点$v_i$到$v_j$、中间顶点的序号不大于$k$的最短路径的长度，$A^{(n-1)}$就是$v_i$到$v_j$的最短路径的长度。

### 算法演示

<img src="E:\Desktop\文章\900px-Floyd-Warshall_example.png" style="zoom:150%;" />



### 代码实现

```
const int maxValue = 9999;//正无穷，当边上的权重为正无穷时表示两个顶点之间没有边
template<class T, class E>
void Floyd(Graphmtx<T, E> & G, E * *a, int** path) {
    //图G由邻接矩阵实现
	//Floyd算法，计算每一对顶点间最短路径及最短路径长度
	//a[i][j]是顶点i和j之间的最短路径长度
	//path[i][j]是相应路径上顶点j的前一顶点的顶点号
	int i, j, k, n = G.NumberOfVertices();
	for (i = 0; i < n; i++)//矩阵a与path的初始化
		for (j = 0; j < n; j++) {
			a[i][j] = G.getWeight(i, j);
			if (i != j && a[i][j] < maxValue)path[i][j] = i;
			else path[i][j] = 0;
		}
	for (k = 0; k < n; k++) //针对每一个k，产生a(k)及path(k)
		for (i = 0; i < n; i++)
			for (j = 0; j < n; j++)
				if (a[i][k] + a[k][j] < a[i][j]) {
					a[i][j] = a[i][k] + a[k][j];
					path[i][j] = path[k][j];//缩短路径长度，绕过k到j
				}
}
```

### 算法分析

